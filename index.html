<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>ç‰©ç†å¼•æ“ x ä»»å‹™ç³»çµ± v1.6.5</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; overflow: hidden; background: #eef; }
    #viewport {
      width: 100vw; height: 100vh;
      position: relative; overflow: hidden;
    }

    /* è¦–å·®èƒŒæ™¯å±¤ */
    #parallaxFar, #parallaxMid {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background-repeat: repeat-x;
      pointer-events: none;
    }
    #parallaxFar {
      background-image: url('images/bg_far.png');
      background-position: bottom;
      z-index: 0;
      opacity: 0.3; /* é€æ˜åº¦ 0.0ï½1.0 */
    }
    #parallaxMid {
      background-image: url('images/bg_mid.png');
      background-position: bottom;
      z-index: 1;
      opacity: 0.5; /* é€æ˜åº¦ 0.0ï½1.0 */
    }

    /* éŠæˆ²ç•«å¸ƒ */
    canvas {
      position: absolute; top: 0; left: 0;
      z-index: 2;
      display: block;
      background: transparent;
      image-rendering: pixelated;
    }

    /* ä»»å‹™è¦†è“‹å±¤ */
    #taskOverlays {
      position: absolute; top: 0; left: 0;
      z-index: 3;
      pointer-events: none;
    }
    #taskOverlays > * {
      pointer-events: auto;
    }
    #taskOverlays iframe {
      width: 1080px;
      height: 900px;
      border: none;
    }

    /* ä»»å‹™ç·¨è¼¯å™¨ */
    #editor {
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 2px solid #444;
      padding: 20px;
      z-index: 4;
      display: none;
      flex-direction: column;
      width: 320px;
    }
    #editor input[type="text"],
    #editor textarea {
      width: 100%;
      margin-bottom: 10px;
      padding: 6px;
      box-sizing: border-box;
      font-size: 24px;
    }
    #editor textarea {
      height: 100px;
      resize: vertical;
    }
    #editor button {
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="parallaxFar"></div>
    <div id="parallaxMid"></div>
    <canvas></canvas>
    <div id="taskOverlays"></div>
    <div id="editor">
      <input id="taskTitle" type="text" placeholder="ä»»å‹™æ¨™é¡Œ" />
      <textarea id="taskContent" placeholder="ä»»å‹™å…§å®¹"></textarea>
      <div>
        <button id="saveTask">å„²å­˜</button>
        <button id="deleteTask">åˆªé™¤</button>
        <button id="cancelEdit">å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <script src="images/map.js"></script>
  <script>
    // --- åŸºæœ¬è¨­å®šèˆ‡ç•«å¸ƒ ---
    const canvas        = document.querySelector('canvas');
    const viewport      = document.querySelector('#viewport');
    const buffer        = canvas.getContext('2d', { alpha: true });
    const parallaxFar   = document.getElementById('parallaxFar');
    const parallaxMid   = document.getElementById('parallaxMid');

    let game_switch    = true;
    let debugCollision = false;
    let boardVisible   = false;

    const RENDER_SCALE = 4.5;
    const ENTITY_SCALE = 0.5;

    // ç›¸æ©Ÿ
    let camera = { x: 0, y: 0 };

    // è¼‰å…¥ Map
    if (!window.TileMaps || !TileMaps["map"]) {
      throw new Error("map.js å°šæœªè¼‰å…¥æˆ– TileMaps ç‰©ä»¶ä¸å­˜åœ¨ã€‚");
    }
    const mapData   = TileMaps["map"];
    const TILE_SIZE = mapData.tileheight;

    // è§£æåœ–å±¤èˆ‡ç¢°æ’ç›’
    const tileLayers = mapData.layers
      .filter(l => l.type === "tilelayer" && l.visible)
      .map(l => ({
        name:   l.name,
        widthPx:  mapData.width  * TILE_SIZE,
        heightPx: mapData.height * TILE_SIZE,
        data:     l.data
      }));
    const collisionBoxes = (mapData.layers
      .find(l => l.type === "objectgroup" && l.name === "collision")
      ?.objects || []
    ).map(o => ({
      x: o.x, y: o.y, width: o.width, height: o.height
    }));

    // clamp å·¥å…·
    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    // --- æ”¯æ´ Tiled Animated Tiles ---
    const animatedTiles = {};
    for (let ts of mapData.tilesets) {
      if (!ts.tiles) continue;
      const baseGid = ts.firstgid;
      for (let tile of ts.tiles) {
        if (tile.animation) {
          const gid = tile.id + baseGid;
          animatedTiles[gid] = {
            frames:    tile.animation.map(f => f.tileid + baseGid),
            durations: tile.animation.map(f => f.duration),
            index:     0,
            timer:     0
          };
        }
      }
    }
    function updateTileAnimations(dt) {
      for (let at of Object.values(animatedTiles)) {
        at.timer += dt;
        while (at.timer >= at.durations[at.index]) {
          at.timer -= at.durations[at.index];
          at.index = (at.index + 1) % at.frames.length;
        }
      }
    }

    // --- Animation & Entity é¡åˆ¥ (ä¿æŒåŸæ¨£) ---
    class Animation {
      constructor() {
        this.states   = {};
        this.current  = "idle";
        this.frameSet = [];
        this.frameIndex = 0;
        this.count    = 0;
        this.delay    = 10;
        this.width    = 32;
        this.height   = 32;
        this.frame    = 0;
      }
      defineState(name, frameSet, delay=10, w=32, h=32) {
        this.states[name] = { frameSet, delay, width: w, height: h };
      }
      setState(name) {
        if (this.current !== name && this.states[name]) {
          const s = this.states[name];
          this.frameSet   = s.frameSet;
          this.delay      = s.delay;
          this.width      = s.width;
          this.height     = s.height;
          this.current    = name;
          this.frameIndex = 0;
          this.count      = 0;
          this.frame      = s.frameSet[0];
        }
      }
      update() {
        if (!this.frameSet.length) return;
        this.count++;
        if (this.count >= this.delay) {
          this.count = 0;
          this.frameIndex = (this.frameIndex + 1) % this.frameSet.length;
          this.frame = this.frameSet[this.frameIndex];
        }
      }
    }

    class Entity {
      constructor(x=0, y=0, w=32, h=32, color='red', velocity=1) {
        Object.assign(this, { x, y, width: w, height: h, color, velocity, gravity: 0, flip: false });
        this.image     = new Image();
        this.animation = new Animation();
        this.onGround  = false;
        this.name      = "";
      }
      save() {
        return { name:this.name, x:this.x, y:this.y, flip:this.flip, state:this.animation.current };
      }
      load(data) {
        if (!data) return;
        this.x    = data.x;
        this.y    = data.y;
        this.flip = data.flip;
        this.animation.setState(data.state);
      }
      drawSprite(scale = 1, tintColor = { r: 235, g: 9, b: 9 }, tintAlpha = 0, blendMode = 'soft-light') {
        const sw = this.animation.width;
        const sh = this.animation.height;
        const offCanvas = document.createElement('canvas');
        const offCtx    = offCanvas.getContext('2d');
        offCanvas.width = sw; offCanvas.height = sh;

        // åŸå§‹å¹€
        offCtx.drawImage(
          this.image,
          this.animation.frame * sw, 0, sw, sh,
          0, 0, sw, sh
        );
        // æŸ“è‰²å±¤
        offCtx.globalCompositeOperation = blendMode;
        offCtx.fillStyle = `rgba(${tintColor.r}, ${tintColor.g}, ${tintColor.b}, ${tintAlpha})`;
        offCtx.fillRect(0, 0, sw, sh);
        // é€æ˜é®ç½©
        offCtx.globalCompositeOperation = 'destination-in';
        offCtx.drawImage(
          this.image,
          this.animation.frame * sw, 0, sw, sh,
          0, 0, sw, sh
        );
        // ä¸»ç•«å¸ƒ
        buffer.save();
        buffer.scale(this.flip ? -1 : 1, 1);
        const dx = this.flip
          ? -(this.x * RENDER_SCALE + this.width * RENDER_SCALE * scale)
          : this.x * RENDER_SCALE;
        buffer.drawImage(
          offCanvas,
          0, 0, sw, sh,
          dx, this.y * RENDER_SCALE,
          this.width * RENDER_SCALE * scale,
          this.height * RENDER_SCALE * scale
        );
        buffer.restore();
      }
      physics(gravity=0.6) {
        this.gravity += gravity;
        this.y += this.gravity;
      }
      checkCollision(boxes, scale = 1) {
        this.onGround = false;
        const sw = this.width * scale;
        const sh = this.height * scale;
        const nextX = this.x;
        const nextY = this.y + this.gravity;
        for (let b of boxes) {
          const bx = b.x, by = b.y, bw = b.width, bh = b.height;
          const collided =
            nextX + sw > bx &&
            nextX < bx + bw &&
            nextY + sh > by &&
            nextY < by + bh;
          if (!collided) continue;
          const dx = (nextX + sw / 2) - (bx + bw / 2);
          const dy = (nextY + sh / 2) - (by + bh / 2);
          const wy = (sw + bw) / 2;
          const hx = (sh + bh) / 2;
          if (Math.abs(dx) <= wy && Math.abs(dy) <= hx) {
            const wy_diff = wy - Math.abs(dx);
            const hx_diff = hx - Math.abs(dy);
            if (wy_diff < hx_diff) {
              // å·¦å³ç‰†
              if (dx > 0) this.x = bx + bw;
              else        this.x = bx - sw;
            } else {
              // åœ°æ¿ / å¤©èŠ±æ¿
              if (dy > 0) {
                this.y = by + bh; this.gravity = 0;
              } else {
                this.y = by - sh; this.gravity = 0; this.onGround = true;
              }
            }
          }
        }
      }
      follow(target) {
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 20) {
          this.x += this.velocity * dx / dist;
          this.y += this.velocity * dy / dist;
          this.animation.setState("run");
        } else this.animation.setState("idle");
        this.flip = this.x > target.x;
        this.animation.update();
      }
      hitbox(alpha=1, scale=1) {
        buffer.save();
        buffer.globalAlpha = alpha;
        buffer.fillStyle   = this.color;
        buffer.fillRect(
          this.x*RENDER_SCALE, this.y*RENDER_SCALE,
          this.width*RENDER_SCALE*scale, this.height*RENDER_SCALE*scale
        );
        buffer.restore();
      }
    }

    // --- åœ–å¡Šèˆ‡ç¢°æ’ç¹ªè£½ ---
    const tileImage = new Image();
    tileImage.src   = "images/SpriteSheet.png";

    function drawTileLayer(layer) {
      const tilesPerRow = tileImage.width / TILE_SIZE | 0;
      let i = 0;
      for (let ty = 0; ty < mapData.height; ty++) {
        for (let tx = 0; tx < mapData.width; tx++) {
          let gid = layer.data[i++];
          if (!gid) continue;
          if (animatedTiles[gid]) {
            gid = animatedTiles[gid].frames[animatedTiles[gid].index];
          }
          const t  = gid - 1;
          const sx = (t % tilesPerRow) * TILE_SIZE;
          const sy = Math.floor(t / tilesPerRow) * TILE_SIZE;
          buffer.drawImage(
            tileImage,
            sx, sy, TILE_SIZE, TILE_SIZE,
            tx*TILE_SIZE*RENDER_SCALE,
            ty*TILE_SIZE*RENDER_SCALE,
            TILE_SIZE*RENDER_SCALE,
            TILE_SIZE*RENDER_SCALE
          );
        }
      }
    }

    function drawCollisionBoxes(boxes, scale=1, fillColor='rgba(0,0,255,0.3)', borderColor='blue') {
      buffer.save();
      buffer.fillStyle   = fillColor;
      buffer.strokeStyle = borderColor;
      for (let b of boxes) {
        buffer.fillRect(
          b.x*scale*RENDER_SCALE, b.y*scale*RENDER_SCALE,
          b.width*scale*RENDER_SCALE, b.height*scale*RENDER_SCALE
        );
        buffer.strokeRect(
          b.x*scale*RENDER_SCALE, b.y*scale*RENDER_SCALE,
          b.width*scale*RENDER_SCALE, b.height*scale*RENDER_SCALE
        );
      }
      buffer.restore();
    }

    // --- ç›¸æ©Ÿæ›´æ–° + è¦–å·®æ›´æ–° ---
    function updateCamera(target) {
      let cx = target.x*RENDER_SCALE - viewport.clientWidth/2;
      let cy = target.y*RENDER_SCALE - viewport.clientHeight/2;
      camera.x = Math.round(clamp(cx, 0, canvas.width - viewport.clientWidth));
      camera.y = Math.round(clamp(cy, 0, canvas.height - viewport.clientHeight));
      // åŒæ­¥ DOM è¦–å·®
      parallaxFar.style.backgroundPosition = `${-camera.x * 0.2}px bottom`;
      parallaxMid.style.backgroundPosition = `${-camera.x * 0.5}px bottom`;
    }

    // --- è¼¸å…¥æ§åˆ¶ ---
    let control_right=false, control_left=false, control_up=false;
    function keyboard_mod(type, value) {
      addEventListener(type, e => {
        if (e.code==='KeyD') control_right = value;
        else if (e.code==='KeyA') control_left  = value;
        else if (e.code==='KeyW') control_up    = value;
      });
    }
    keyboard_mod('keydown', true);
    keyboard_mod('keyup',   false);

    function control(role) {
      if (control_right) {
        role.x += 1.5; role.flip = false; role.animation.setState("run");
      }
      else if (control_left) {
        role.x -= 1.5; role.flip = true;  role.animation.setState("run");
      }
      else if (!role.onGround) {
        role.animation.setState("jump");
      }
      else role.animation.setState("idle");
      if (control_up && role.onGround) role.gravity = -8;
    }

    // --- å¯¦é«” & å‹•ç•«è¨­å®š ---
    const user = new Entity(250, 0, 57.6,61.2);
    const npc  = new Entity(200, 0, 32,32);
    user.name = "user"; npc.name = "npc";
    user.image.src = "images/role1.png";
    npc.image.src  = "images/npc.png";

    user.animation.defineState("idle", [0,1], 15, 48,51);
    user.animation.defineState("run",  [2,3,4,5], 4, 48,51);
    user.animation.defineState("jump", [6,7], 10, 48,51);
    npc.animation.defineState("idle", [0,1,2,3], 20, 23,27);
    npc.animation.defineState("run",  [4,5,6,7,8,9], 5, 23,27);

    const allEntities     = [user, npc];
    const physicsEntities = [user, npc];

    // --- å„²å­˜ / è¼‰å…¥éŠæˆ² ---
    function saveGame() {
      const states = allEntities.map(e => e.save());
      localStorage.setItem('gameSave', JSON.stringify({ entities: states }));
    }
    function loadGame() {
      const data = JSON.parse(localStorage.getItem('gameSave'));
      if (!data || !Array.isArray(data.entities)) return;
      for (let s of data.entities) {
        const e = allEntities.find(x => x.name === s.name);
        if (e) e.load(s);
      }
    }

    // --- ä»»å‹™ç³»çµ± UI (ä¿æŒåŸæ¨£) ---
    let tasks = JSON.parse(localStorage.getItem("canvasTasks")||"[]");
    tasks.forEach(t => { if (t.iframeVisible === undefined) t.iframeVisible = false; });
    let draggingTask=null, dragOffset={x:0,y:0};
    let selectedTaskId=null;

    const editor          = document.getElementById("editor");
    const titleInput      = document.getElementById("taskTitle");
    const contentTextarea = document.getElementById("taskContent");
    const saveBtn         = document.getElementById("saveTask");
    const deleteBtn       = document.getElementById("deleteTask");
    const cancelBtn       = document.getElementById("cancelEdit");

    function saveTasks() {
      localStorage.setItem("canvasTasks", JSON.stringify(tasks));
    }
    function wrapTextCentered(text, cx, sy, maxW, lh) {
      const words = text.split(' ');
      let line="", y=sy, lines=[];
      for (let w of words) {
        const t = line + w + ' ';
        if (buffer.measureText(t).width > maxW && line.length) {
          lines.push(line); line = w + ' ';
        } else line = t;
      }
      lines.push(line);
      for (let l of lines) {
        buffer.fillText(l.trim(), cx, y);
        y += lh;
      }
    }
    function drawBoard() {
      const panelX = 100, panelY = 100;
      const panelW = viewport.clientWidth - 200;
      const panelH = viewport.clientHeight - 200;

      buffer.save();
      buffer.fillStyle = "rgba(34,34,34,0.5)";
      buffer.fillRect(panelX,panelY,panelW,panelH);

      buffer.fillStyle = "#ffd700";
      buffer.font = "bold 48px sans-serif";
      buffer.textAlign = "center";
      buffer.fillText("æ‡¸è³ä»»å‹™", panelX + panelW/2, panelY + 50);

      // æ–°å¢æŒ‰éˆ•
      const addBtnX = panelX + panelW - 60;
      const addBtnY = panelY + 20;
      buffer.fillStyle = "#0f0";
      buffer.fillRect(addBtnX, addBtnY, 40, 40);
      buffer.fillStyle = "#000";
      buffer.font = "bold 30px sans-serif";
      buffer.fillText("+", addBtnX+20, addBtnY+30);

      const overlayContainer = document.getElementById("taskOverlays");
      overlayContainer.innerHTML = "";

      for (let t of tasks) {
        buffer.fillStyle = "#fff";
        buffer.fillRect(t.x,t.y,220,80);
        buffer.strokeStyle = "#000";
        buffer.strokeRect(t.x,t.y,220,80);
        buffer.fillStyle = "#000";
        buffer.font = "bold 18px sans-serif";
        buffer.textAlign = "center";
        wrapTextCentered(t.title || "(ç„¡æ¨™é¡Œ)", t.x+110, t.y+25, 200, 22);

        if (t.content.trim().startsWith("<iframe")) {
          const toggleBtn = document.createElement("button");
          toggleBtn.innerText = t.iframeVisible ? "âŒ" : "ğŸŸ¢";
          toggleBtn.style.position = "absolute";
          toggleBtn.style.left = `${t.x + 10}px`;
          toggleBtn.style.top = `${t.y + 50}px`;
          toggleBtn.style.zIndex = 20;
          toggleBtn.onclick = () => {
            t.iframeVisible = !t.iframeVisible;
            saveTasks();
            drawBoard();
          };
          overlayContainer.appendChild(toggleBtn);

          if (t.iframeVisible) {
            const div = document.createElement("div");
            div.style.position = "absolute";
            div.style.left = "50%";
            div.style.top  = "50%";
            div.style.width = "90vw";
            div.style.height = "90vh";
            div.style.pointerEvents = "auto";
            div.innerHTML = t.content;
            overlayContainer.appendChild(div);
          }
        }
      }
      buffer.restore();
    }

    // --- ä»»å‹™äº’å‹•äº‹ä»¶
    canvas.addEventListener("mousedown", e => {
      if (!boardVisible) return;
      const x=e.offsetX, y=e.offsetY;
      const addBtnX = 100 + (viewport.clientWidth-200) - 60;
      const addBtnY = 120;
      const centerX = camera.x + viewport.clientWidth / 2;
      const centerY = camera.y + viewport.clientHeight / 2;
      if (x>=addBtnX && x<=addBtnX+40 && y>=addBtnY && y<=addBtnY+40) {
        const nt = { id:Date.now(), title:"", content:"", x: centerX - 110, y: centerY - 40, iframeVisible: false };
        tasks.push(nt); saveTasks();
        selectedTaskId = nt.id;
        titleInput.value=""; contentTextarea.value="";
        editor.style.display="flex";
        drawBoard(); return;
      }
      for (let t of tasks) {
        if (x>=t.x && x<=t.x+220 && y>=t.y && y<=t.y+80) {
          selectedTaskId = t.id;
          dragOffset.x = x - t.x;
          dragOffset.y = y - t.y;
          draggingTask = t;
          return;
        }
      }
    });
    canvas.addEventListener("mousemove", e => {
      if (boardVisible && draggingTask) {
        draggingTask.x = e.offsetX - dragOffset.x;
        draggingTask.y = e.offsetY - dragOffset.y;
        drawBoard();
      }
    });
    canvas.addEventListener("mouseup", () => {
      if (boardVisible && draggingTask) saveTasks();
      draggingTask = null;
    });
    canvas.addEventListener("dblclick", e => {
      if (!boardVisible) return;
      const x=e.offsetX, y=e.offsetY;
      for (let t of tasks) {
        if (x>=t.x && x<=t.x+220 && y>=t.y && y<=t.y+80) {
          selectedTaskId = t.id;
          titleInput.value   = t.title;
          contentTextarea.value = t.content;
          editor.style.display  = "flex";
          return;
        }
      }
    });
    saveBtn.onclick = () => {
      const t = tasks.find(x => x.id === selectedTaskId);
      if (t) {
        t.title   = titleInput.value.trim();
        t.content = contentTextarea.value.trim();
        saveTasks();
        editor.style.display = "none";
        if (boardVisible) drawBoard();
      }
    };
    deleteBtn.onclick = () => {
      tasks = tasks.filter(x => x.id !== selectedTaskId);
      saveTasks();
      editor.style.display = "none";
      if (boardVisible) drawBoard();
    };
    cancelBtn.onclick = () => {
      editor.style.display = "none";
      if (boardVisible) drawBoard();
    };

    // å¿«æ·éµ
    addEventListener('keydown', e => {
      if (e.code === 'KeyK') {
        if (editor.style.display === "flex") return;
        boardVisible = !boardVisible;
        const overlay = document.getElementById("taskOverlays");
        if (boardVisible) drawBoard();
        else {
          overlay.innerHTML = "";
          main_loop(lastTime);
        }
      }
      if (e.code === 'KeyP') {
        game_switch = !game_switch;
        if (game_switch && !boardVisible) main_loop(lastTime);
      }
      if (e.code === 'KeyH') debugCollision = !debugCollision;
      if (e.code === 'ArrowUp') saveGame();
      if (e.code === 'ArrowDown') loadGame();
    });

    // èª¿æ•´ç•«å¸ƒ
    function resizeCanvas() {
      canvas.width  = mapData.width  * TILE_SIZE * RENDER_SCALE;
      canvas.height = mapData.height * TILE_SIZE * RENDER_SCALE;
      buffer.imageSmoothingEnabled = false;
    }

    // --- ä¸»è¿´åœˆèˆ‡å•Ÿå‹• ---
    let lastTime = performance.now();
    function main_loop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      if (!game_switch) return;
      if (boardVisible) return drawBoard();

      requestAnimationFrame(main_loop);

      // æ›´æ–°å‹•ç•«
      updateTileAnimations(dt);

      // ç‰©ç†èˆ‡ç¢°æ’
      for (let e of physicsEntities) {
        e.physics();
        e.checkCollision(collisionBoxes, ENTITY_SCALE);
      }

      // æ§åˆ¶èˆ‡ NPC è·Ÿéš¨
      control(user);
      user.animation.update();
      npc.follow(user);

      // æ›´æ–°ç›¸æ©Ÿ (å«è¦–å·®)
      updateCamera(user);

      // ç¹ªè£½
      buffer.clearRect(0, 0, canvas.width, canvas.height);
      buffer.save();
      buffer.translate(-camera.x, -camera.y);

      for (let layer of tileLayers) drawTileLayer(layer);
      if (debugCollision) {
        drawCollisionBoxes(collisionBoxes);
        user.hitbox(0.5, ENTITY_SCALE);
        npc.hitbox(1.0, ENTITY_SCALE);
      }
      user.drawSprite(ENTITY_SCALE);
      npc.drawSprite(ENTITY_SCALE);

      buffer.restore();
    }

    // å•Ÿå‹•
    resizeCanvas();
    requestAnimationFrame(main_loop);
  </script>
</body>
</html>
